{
  "version": 3,
  "sources": ["../src/index.ts", "../src/cascader/cascader.ts", "../src/register/register.ts", "../src/utils/cascade.ts", "../src/utils/catalog.ts", "../src/utils/config.ts"],
  "sourcesContent": ["import { Cascader } from './cascader'\nimport { registerComponents, registerCustomFind } from './register'\nexport * from './types'\nexport {\n  Cascader,\n  registerComponents,\n  registerCustomFind\n}", "/** @module Cascader */\nimport type { ReactNode } from 'react'\nimport type {\n  TCascade,\n  TNodeProps,\n  TReactComp,\n  TCascadeNode,\n  TCascadeItem,\n  TCascadeMeta,\n  TCatalogProps,\n} from '../types'\n\n\nimport { useEffect, createElement } from 'react'\nimport { findComponent, getCached, addCached } from '../register'\nimport { buildCascadeProps, updateCatalogProps, buildConfig } from '../utils'\nimport { isObj, isArr, isFunc, eitherObj, isColl, get, checkCall } from '@keg-hub/jsutils'\n\n/**\n * Gets a component from cache or tries to find it in the registered components\n * <br> Also add to cache when a component is found, and the node has an id\n */\nconst getComponent = (\n  cascade:TCascadeNode,\n  metadata:TCascadeMeta,\n  props:TNodeProps,\n  parent:TNodeProps\n) => {\n  const { catalog, buildCatalog } = metadata\n  const { id } = props\n\n  // Check if the comp is cached\n  const CachedComp = id && getCached(id)\n\n  // If no cached comp, Try to find it\n  const FoundComp = CachedComp || findComponent(cascade, props, metadata, parent)\n\n  // Cache the found component which should make next render faster\n  // Add cached component if there's no cached component and a function component was found\n  id && !CachedComp && isFunc(FoundComp) && addCached(id, FoundComp)\n  \n  // Update the catalog with update props when an id exists and buildCatalog === true\n  id && buildCatalog && updateCatalogProps(\n    eitherObj<TCatalogProps, TCatalogProps>(catalog[id], {} as TCatalogProps),\n    props,\n    metadata\n  )\n\n  // Return the found component\n  return FoundComp as TReactComp\n}\n\n/**\n * Creates a React component by calling the React.createElement method\n */\nconst getRenderEl = (\n  cascade:TCascadeNode,\n  metadata:TCascadeMeta,\n  props:TNodeProps,\n  parent:TNodeProps\n):ReactNode => {\n\n  // Create the react version of the element\n  return createElement(\n    // Get the component to use, either a string || React function component\n    getComponent(cascade, metadata, props, parent),\n    props,\n    // Render the children of the cascade node\n    renderCascade(\n      cascade[2],\n      metadata,\n      { cascade, parent, props }\n    )\n  )\n}\n\n/**\n * Builds a single cascade node and returns it, or null if node can not be built\n */\nconst buildCascadeNode = (\n  cascade:TCascadeNode,\n  metadata:TCascadeMeta,\n  parent:TNodeProps\n) => {\n\n  // If no cascade, or no type, return null\n  return !cascade || !cascade[0]\n    ? null\n    : getRenderEl(\n        cascade,\n        metadata,\n        // Build the props for the cascade node\n        eitherObj(buildCascadeProps(cascade, metadata, parent), {}),\n        parent\n      )\n}\n\n/**\n * Loops an array, calling renderCascade on each element\n */\nconst loopCascadeArray = (\n  cascade:TCascadeNode[],\n  metadata:TCascadeMeta,\n  parent:TNodeProps\n):ReactNode[] => {\n  // Cache the current pos, because we update metadata in place\n  // This keeps the correct pos for each child of the cascade\n  const curPos = metadata.pos\n\n  return cascade.map((child, index) => {\n    // Update the pos for the child node\n    metadata.pos = `${curPos}.2.${index}`\n\n    return renderCascade(child, metadata, parent)\n  })\n}\n\n/**\n * Recursively converts cascade to React.createElement\n * @function\n * @param {Object} cascade - The nodes to be rendered\n * @param {Object} metadata - Extra data for cascade nodes\n * @param {Object} parent - Cascade nodes parent data\n *\n * @return {Object} rendered React vDom elements\n */\nconst renderCascade = (\n  cascade:TCascadeNode|TCascadeItem,\n  metadata:TCascadeMeta,\n  parent:TNodeProps\n):ReactNode => {\n  // If not a collection, it should just return the value\n  return !isColl(cascade)\n    ? cascade\n    // If first element is Loading, return null\n    // Helper for returning when an element needs to wait due to loading\n    : cascade[0] === metadata.isLoading\n      ? null\n      : isArr(cascade)\n        // Get the element to be rendered, and return it\n        // Check if cascade is an array\n        // Recursively loop and render the elements of the ray\n        ? loopCascadeArray(cascade, metadata, parent)\n        : buildCascadeNode(cascade, metadata, parent)\n}\n\n/**\n * Kicks off the cascade render\n * <br> Validates passed in props, and logs warning when they are incorrect\n */\nexport const Cascader = (props:TCascade) => {\n\n  // Ensure a cascade object exists\n  if(!isObj(props) || !isColl(props.cascade)){\n    console.warn(`Cascader requires a cascade object as a prop!`, props)\n    return null\n  }\n\n  if(props.catalog && !isObj(props.catalog)){\n    console.warn(`Cascader requires the catalog prop to be an object or falsy!`, props)\n    return null\n  }\n\n  if(props.events && !isObj(props.events)){\n    console.warn(`Cascader requires the events prop to be an object or falsy!`, props)\n    return null\n  }\n\n  // Join the passed in config with the default config\n  const config = buildConfig(props.config)\n\n  const metadata:TCascadeMeta = {\n    catalog: isObj(props.catalog) && props.catalog || {},\n    styles: props.styles,\n    events:  props.events,\n    config: config,\n    // Cache the CASCADE_LOADING value, so we don't have to look it up each time\n    isLoading: get(config, [ 'constants', 'CASCADE_LOADING' ]),\n    // Check if the catalog should be built while rendering\n    // If there is a getCatalog method, and\n    // The config.catalog.build options is not set to false\n    buildCatalog: props.getCatalog && get(config, [ 'catalog', 'build' ]) !== false,\n    // Default position of the root cascade node\n    pos: '0',\n  }\n\n  // If a getCatalog is passed in\n  // Add the useEffect to call the callback after render\n  props.getCatalog && useEffect(() => checkCall(props.getCatalog, metadata.catalog))\n\n  // Render the Cascade\n  return renderCascade(props.cascade, metadata, eitherObj(props.parent, {}))\n\n}", "/** @module Registry */\n\nimport type {\n  TNodeProps,\n  TComponent,\n  TMetaLookup,\n  TCascadeNode,\n  TCascadeMeta,\n  TFindComponent,\n  TComponentList,\n  TCachedComponents,\n} from '../types'\n\nimport { isObj, get, capitalize, isFunc, isStr } from '@keg-hub/jsutils'\nimport { getAltRender, getCascadeId } from '../utils'\n\n// Helper to known then running tests\nconst isTest = process.env.NODE_ENV === 'test'\n\n/**\n * Eventually want to have multiple registries, which can be referenced by id\n * <br> Which why this is a class\n * <br> Then we could create multiple Registry instance\n * <br> This would allow different registered components for different cascade instances\n * @class Registry\n */\nclass Registry {\n\n  // Cache to hold cache items\n  cached:TCachedComponents = {}\n  components:TComponentList = {}\n  customFind?:TFindComponent\n\n  /**\n  * Register a group of components to be searched when rendering\n  * @memberof Registry\n  * @function\n  * @param {Object} compList - Group of React Components\n  *\n  * @returns {void}\n  */\n  register = (compList:TComponentList) => {\n    if(!isObj(compList))\n      return console.warn(`Cascade register method only accepts an object as it's first argument!`)\n    \n    // Join the current components with the passed in compList\n    this.components = { ...this.components, ...compList, }\n\n    return this.components\n  }\n\n  /**\n   * Removes a single component or all components\n   * @memberof Registry\n   */\n  unset = (key?:string) => (key ? (delete this.components[key]) : (this.components = {}))\n\n  /**\n   * Gets a single registered component or all components\n   * @memberof Registry\n   */\n  get = (key?:string) => (key ? this.components[key] : this.components)\n\n  /**\n  * Finds a registered React Component that matches the cascade node\n  * <br> Looks for components in this order\n  * <br> 1. altRender || render key on the catalogProps of the cascade\n  * <br> 2. capitalize(node[0]) - The type of the passed in cascade node but capitalized\n  * <br> 3. node[0] (type) - The type of the passed in cascade node\n  * <br> 4. node[1].id (id) - The id of the passed in cascade node\n  * <br> 5. If no component is found, node[0] (type) is returned\n  * @memberof Registry\n  * @function\n  * @param {Object} cascade - Node describing a UI element\n  * @param {Object} props - properties of the cascade node\n  * @param {Object} catalog - Lookup table for cascade nodes\n  *\n  * @returns {React Component} - Matching registered component\n  */\n  find = (\n    cascade:TCascadeNode,\n    props:TNodeProps,\n    { catalog, config }:TCascadeMeta,\n  ) => {\n    \n    const lookup = get(config, [ 'components', 'lookup' ], {})\n\n    // If not cascade just return\n    if(!cascade)\n      return console.warn(`Find requires a cascade object as it's first argument`, cascade)\n    \n    if(!isObj(lookup))\n      return console.warn(`config.component.lookup must be of type object`, lookup)\n\n    // Find the Id of the cascade node\n    const cascadeId = getCascadeId(cascade, props)\n\n    // Use cascade Id to get the render key of the cascade node\n    const renderKey = cascadeId && getAltRender(\n      catalog,\n      cascadeId,\n      lookup as TMetaLookup\n    )\n    \n    // Get the cascade type\n    const type = cascade[0]\n\n    // Look for the component by key, type, id || just return the original type\n    return this.components[renderKey] ||\n      lookup.capitalize && this.components[capitalize(type)] ||\n      lookup.type && this.components[type] ||\n      lookup.id && this.components[cascadeId] ||\n      type\n  }\n\n  /**\n  * Clears out cache and components\n  * @memberof Registry\n  * @function\n  *\n  * @returns {void}\n  */\n  clear = () => {\n    this.cached = {}\n    this.unset()\n  }\n\n}\n\nconst registry = new Registry()\n\n/**\n * Register a custom Registry.find method\n * @function\n *\n * @param {function} customFind - custom function to override the default find function\n */\nexport const registerCustomFind = (customFind:TFindComponent) => (\n  !customFind\n    ? (registry.customFind = undefined)\n    : ( isFunc(customFind) && (registry.customFind = customFind.bind(registry)) )\n)\n\n/**\n * Register a group of components to be searched when rendering\n * @function\n * @param {Object} compList - Group of React Components\n *\n * @returns {void}\n */\nexport const registerComponents = registry.register\n\n/**\n * Removes a single component from the component registry\n * @function\n * @param {string} key - key of component to remove\n *\n * @returns {void}\n */\nexport const removeComponent = (key:string) => isStr(key) && registry.unset(key)\n\n/**\n * Removes all registered components\n * @function\n *\n * @returns {void}\n */\nexport const removeComponents = () => registry.unset()\n\n/**\n * Gets a single registered component based on the passed in key\n * @function\n * @param {string} key - key of a registered component\n *\n * @returns {React Component} - Matching registered component\n */\nexport const getComponent = (key:string) => isStr(key) && registry.get(key)\n\n/**\n * Gets all registered components\n * @function\n *\n * @returns {Object} - Key value pair of registered components\n */\nexport const getComponents = () => registry.get()\n\n/**\n * Searches for a component in the registered components\n * <br> If a customFind method is set it will call that method instead\n * @function\n * @returns {Object} - Key value pair of registered components\n */\nexport const findComponent = (\n  cascade:TCascadeNode,\n  props:TNodeProps,\n  meta:TCascadeMeta,\n  parent?:TNodeProps\n) => (\n  isFunc(registry.customFind)\n    ? registry.customFind(cascade, props, meta, parent)\n    : registry.find(cascade, props, meta)\n)\n\n/**\n * Gets a cached component based on the passed in id\n * @param {string} id - id of a registered component\n *\n * @returns {React Component} - Matching cached component\n */\nexport const getCached = (id:string):TComponent => {\n  return registry.cached[id as keyof typeof registry.cached]\n}\n\n/**\n * Adds a cached component based on the passed in id\n * @function\n */\nexport const addCached = (id:string, comp:TComponent=null):TComponent => {\n  if(!isStr(id)){\n    console.warn(`addCached requires an Id as a string for the first arguemnt!`, id)\n    return\n  }\n\n  if(!isFunc(comp)){\n    console.warn(`addCached requires a function component as the second argument!`, comp)\n    return\n  }\n\n  registry.cached[id] = comp\n\n  return registry.cached[id]\n}\n\n/**\n * Clears out cached components based on passed in id\n * <br> If no id, it will remove all cached components\n * <br> If an id is passed, it will remove only the matching cached item\n */\nexport const clearCache = (id:string) => {\n  // If no id, clear all the cache\n  if(!id) return registry.cached = {}\n  \n  // If an id is passed, remove just the matching cached component\n  delete registry.cached[id]\n}\n\n/**\n * Clears out cache and components\n * @function\n *\n * @returns {void}\n */\nexport const clear = registry.clear", "/** @module Utils */\nimport type {\n  TNodeProps,\n  TMetaEvents,\n  TCascadeMeta,\n  TCascadeNode,\n  TCascadeParent,\n} from '../types'\nimport { get, isObj, isStr, deepMerge, reduceObj } from '@keg-hub/jsutils'\n\n/**\n * Adds events to the props of elements based on type of Id\n * If both match, Id overrides type\n\n */\nconst addEvents = (events:TMetaEvents, type:any, props:TNodeProps):TCascadeNode => (\n  reduceObj(events, (evtName, addTo) => {\n    // Check if there's a type match\n    addTo[type] && (props[evtName] = addTo[type])\n    // ID should override type, so check if there's a id match after type\n    addTo[props.id] && (props[evtName] = addTo[props.id])\n\n    return props\n  })\n)\n\n/**\n * Builds the props of a cascade node\n */\nexport const buildCascadeProps = (\n  cascade:TCascadeNode,\n  metadata:TCascadeMeta,\n  parent:TCascadeParent\n):TNodeProps => {\n  // Get the props directly on the cascade node\n  const inlineProps = get(cascade, [ '1' ], {})\n\n  // Get the catalog from finding the cascade node metadata\n  const { catalog, events } = metadata\n\n  // Get the id for the cascade, if no Id in the props, try to get the id from the position\n  const cascadeId = getCascadeId(cascade, inlineProps)\n\n  // If no id on the inline props, then no way to get metadata props || parent props\n  // If there is an id, get the metadata && parent props\n  const cascadeProps = !cascadeId\n    ? inlineProps as TNodeProps\n    : deepMerge(\n        get(parent, [ 'props', 'children', cascadeId ]),\n        catalog[cascadeId],\n        inlineProps\n      ) as TNodeProps\n\n  // Ensure a key is added to the props, use either the ID or the pos\n  // If not other key can be used, use the pos from the metadata\n  cascadeProps.key = cascadeProps.key || cascadeProps.id || cascadeProps.pos || metadata.pos\n  \n  return cascade['0'] && isObj(events)\n    ? addEvents(events, cascade['0'], cascadeProps)\n    : cascadeProps\n}\n\n/**\n * Gets the ID of a cascade node from the passed in id || cascade node || props\n */\nexport const getCascadeId = (\n  cascade:TCascadeNode,\n  props:TNodeProps,\n  id?:string\n):string => (\n  (isStr(id) && id)\n  || (isObj(cascade) && ( get(cascade, [ '1', 'id' ]) || !props && get(cascade, [ 'id' ])))\n  || get(props, [ 'id' ])\n)", "/** @module Utils */\n\nimport type {\n  TNodeProps,\n  TMetaLookup,\n  TMetaCatalog,\n  TCascadeMeta,\n  TCascadeNode,\n  TCatalogProps,\n} from '../types'\n\n\nimport { isObj, isStr, isArr, uuid } from '@keg-hub/jsutils'\n\n/**\n * Gets the catalog props based on an ID\n */\nexport const getCatalogProps = (\n  catalog:TMetaCatalog,\n  id:string\n):TCatalogProps => {\n\n  if(!isObj(catalog) || !isStr(id)){\n    console.warn(`getCatalogProps requires a catalog object, and an id!`, catalog, id)\n    return\n  }\n\n  return catalog[id]\n}\n\n/**\n * Updated the catalogProps ID and position (pos)\n */\nexport const updateCatalogProps = (\n  catalogProps:TCatalogProps,\n  props:TNodeProps,\n  metadata: TCascadeMeta\n) => {\n  const { pos, catalog } = metadata\n\n  // Set the id if it does not exist, or it's incorrect\n  props.id && (!catalogProps.id || catalogProps.id !== props.id) &&\n    (catalogProps = { ...catalogProps, id: props.id })\n\n  // Check the pos, and update it if needed\n  isStr(pos) && pos !== catalogProps.pos &&\n    (catalogProps = { ...catalogProps, pos }) \n\n  // If the props are not euqal that means there was an update,\n  // So set the new props to the catalog\n  catalog[props.id] !== catalogProps &&\n    (metadata.catalog = { ...catalog, [props.id]: catalogProps })\n\n}\n\n/**\n * Gets the component key\n * @function\n * @param {Object} catalog - Lookup table for cascade nodes\n * @param {string} id - ID of the cascade node\n * @param {Object} lookup - Config options for how to lookup the render key\n *\n * @returns {string} - Type of component to render (div / img ) || ( React Component )\n */\nexport const getAltRender = (\n  catalog:TMetaCatalog,\n  id:string,\n  lookup?:TMetaLookup\n) => {\n  lookup = { key: 'altRender', altKey: 'render', ...(lookup || {}) }\n  // Get catalogProps based on the id\n  const catalogProps = getCatalogProps(catalog, id)\n\n  // Get the render key || altKey from the catalogProps\n  return isObj(catalogProps) && (catalogProps[lookup.key] || catalogProps[lookup.altKey])\n\n}\n\n/**\n * Builds the catalog props for a cascade node\n * @param {Object} [props={}] - Props from the cascade node\n * @param {boolean} [allProps=false] - Should include all props from the cascade node\n * @param {string} parentPos - Parents nodes position in the cascade\n * @param {string|number} index - current location of the node within the parents children\n *\n * @returns {Object} - Built catalogProps for the cascade node\n */\nconst buildCatalogProps = (\n  props:TNodeProps={},\n  allProps=false,\n  parentPos:string,\n  index:string|number\n) => {\n\n  // Ensure it has an ID\n  const id = (props.id || uuid()) as string\n\n  // Build the position based on the parent and the index\n  const pos = parentPos !== 'ROOT_POS'\n    ? `${parentPos}.2.${ index || 0 }`\n    : '0'\n  \n  // Return the built props\n  return {\n    id,\n    // Ensure a key exists\n    key: props.key || id,\n    // Check if all props from the cascade node should be added\n    ...(allProps && props || {}),\n    pos\n  }\n}\n\n/**\n * Recursively builds the catalog object, keeping track of the position of the cascade\n * @param {Object} cascade - Cascade node to build the catalog from\n * @param {boolean} allProps - Should include all props from the cascade node\n * @param {Object} metaData - Holds the catalog, and cascade position info\n *\n * @returns {Object} - Built catalog object\n */\nconst buildCatalog = (\n  cascade:TCascadeNode|TCascadeNode[]|string,\n  allProps:boolean,\n  { catalog, parentPos, index }:TCascadeMeta\n) => {\n\n  if(isObj<TCascadeNode>(cascade)){\n    // Build the props for the cascade node\n    const props = buildCatalogProps(cascade[1] || {}, allProps, parentPos, index)\n    // Add the props to the catalog\n    catalog[props.id] = props\n    // Build the catalog props for any children of the cascade node\n    buildCatalog(cascade[2], allProps, { catalog, parentPos: props.pos })\n  }\n\n  // If it's an array, loop over the array and build the catalog for each node\n  else if(isArr<TCascadeNode[]>(cascade))\n    cascade.forEach((node, idx) => buildCatalog(\n      node,\n      allProps,\n      { catalog, parentPos, index: idx }\n    ))\n\n  // Return the built catalog\n  return catalog\n}\n\n/**\n * Wrapper around buildCatalog, so the catalog object is managed internally\n * @param {Object} cascade - Root cascade node to build the catalog from\n * @param {boolean} allProps - Should include all props from the cascade node\n *\n * @returns {Object} - Built catalog object\n */\nexport const catalogFromCascade = (\n  cascade:TCascadeNode|TCascadeNode[]|string,\n  allProps:boolean,\n) => {\n  return buildCatalog(cascade, allProps, { catalog: {}, parentPos: 'ROOT_POS' })\n}", "import { deepMerge } from '@keg-hub/jsutils'\n\nconst defConfig = {\n  constants: {\n    CASCADE_LOADING: 'CASCADE_LOADING',\n  },\n  components: {\n    lookup: {\n      key: 'altRender',\n      altKey: 'render',\n      capitalize: true,\n      type: true,\n      id: true\n    }\n  },\n  catalog: {\n    build: true\n  }\n}\n\nexport const buildConfig = (config={}) => {\n  return deepMerge(defConfig, config)\n}"],
  "mappings": "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",
  "names": ["import_jsutils", "import_jsutils", "import_jsutils", "import_jsutils"]
}
